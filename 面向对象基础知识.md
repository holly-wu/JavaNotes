## 面向对象基础知识

### 1. 什么是面向对象
#### 面向对象、面向过程
记得学习面向对象的第一句话，一切都是对象。把处理逻辑抽象为对象，对象具有各自的属性和方法，然后进行后续的开发。

面向过程比较类似数学解题，一步一步的处理操作，然后得到结果。

区别主要就是思维方式以及处理方式的不同，适用场景不一样。
> 参考百度知道用户java118的回答 [地址](https://zhidao.baidu.com/question/2089034.html)：
> 
> 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
> 
> 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
>
> 例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。
>
> 而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。
> 
> 可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。
> 
> 功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。
> 
> 再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。
> 
> 当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。

#### 面向对象的三大基本特征和五大基本原则
封装、继承、多态。

单一职责原则（SRP）：类、方法都应该只有一个职责，从而达到高内聚、低耦合的目标。

开放封闭原则（OCP）：对扩展开放，对修改关闭。提高系统的稳定性，尽量在不修改原有代码的基础上进行后续功能的增加。

里氏替换原则（LSP）：所有使用父类的地方都能直接使用子类替换而不发生错误，反之则不行。在程序中尽量使用父类进行定义，在运行时确定子类对象，使用子类替换。

依赖倒置原则（DIP）：针对抽象编程，针对接口编程，在开发过程中，将依赖的对象通过抽象来注入。

接口隔离原则（ISP）：定义多个专门的接口，而不是使用一个总接口，客户端不依赖不需要的接口，接口粒度要适当。

> 参考博客： [面向对象的三大基本特征，五大基本原则](https://www.cnblogs.com/fzz9/p/8973315.html)

### 2. 平台无关性
#### Java 如何实现的平台无关
Java通过JVM实现它的平台无关性，JVM可以运行在不同的平台上，与不同平台的接入都通过JVM做了，而Java代码只需要运行在JVM上就行了。Java编译后生成字节码文件，通过JVM生成对应平台的机器语言。
> 参考博客：[为什么说Java语言是平台无关的](https://blog.csdn.net/newmemory/article/details/54949817)

#### JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）
// TODO 暂时没有了解，听说过Kotlin
### 3. 值传递
#### 值传递、引用传递
Java方法调用时传递形参

实际参数是参数的值，方法中对形参的改变不影响方法外的相应对象。

实际参数是参数的引用地址，方法中对形参的改变会保留下来，同时影响到方法外的相应对象。

#### 为什么说 Java 中只有值传递
假如有以下方法：

```
public static void main(String[] args) {
   User test = new User();
   test.setName("test");
   test.setGender("Male");
   pass(test);
   System.out.println("print in main , user is " + test);
}

public void pass(User user) {
   user = new User();
   user.setName("hollischuang");
   user.setGender("Male");
   System.out.println("print in pass , user is " + user);
}
```

pass方法对user进行了改变，指向了新的对象地址，但方法外的user仍是以前的test，这是因为pass方法传递的是user的地址的拷贝，当直接对这个地址的对象做改变时，会影响到方法外的相应对象；而当把参数指向新的地址，对新的地址做改变，则不会影响到方法外的相应对象。

所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。
> 参考博客：[为什么说Java只有值传递](https://www.cnblogs.com/wchxj/p/8729503.html)

### 4. 封装、继承、多态
#### 什么是多态、方法重写与重载
封装：就是隐藏对象的属性和实现细节,仅对外提供公共访问方式。
封装的好处:隐藏类的实现细节;让使用者只能通过程序员规定的方法来访问数据;可以方便的加入存取控制语句,限制不合理操作。实例：访问控制符。

继承：子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，子类拥有父类的所有属性和方法。

多态： 是同一个行为具有多个不同表现形式或形态的能力。多态分为两种情况：编译时多态和运行时多态。如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态；在执行期间（非编译期间）判断引用对象的实际类型，根据实际类型判断并调用相应的属性和方法，称为运行时多态。

override：方法重写，子类重写父类方法。体现运行时多态。

overload：方法重载，方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。体现编译时多态。

#### Java的继承与实现
继承：子类继承父类，子类拥有父类的所有属性和方法。

通过extends关键字实现，final类不能被继承。通过super关键字获得父类的引用，this关键字获得本身的引用。

#### 构造函数与默认构造函数
构造函数：是一种特殊的函数，在创建对象时自动调用的初始化对象的函数，其函数名与类名相同，没有返回值类型定义，没有return语句。构造函数可以重载。

默认构造函数：构造函数的一种，当类里面没有定义构造函数，编译器会自动增加一个无参的默认构造函数，如果已经定义构造函数，编译器就不会自动增加了。

#### 类变量、成员变量和局部变量
类变量（静态变量）：类里面在方法、构造方法、语句块外定义的变量，用static修饰。经常被声明为常量，在第一次访问时创建，程序结束时销毁。

成员变量（实例变量）：在方法、构造方法、语句块外定义的变量，在对象创建时候创建，在对象销毁的时候销毁。具有默认值，有访问修饰符。

局部变量：在方法、构造方法或者语句块中定义的方法，作用域仅限于所在方法、构造方法或者语句块，必须在初始化后才能使用。

#### 方法作用域

访问修饰符|同一个类|同一个包|子类|外部包
:-:|:-:|:-:|:-:|:-:
public|Y|Y|Y|Y
protected|Y|Y|Y|N
default|Y|Y|N|N
private|Y|N|N|N

#### 接口
接口：是抽象方法的集合，用interface声明，其实现类通过implements关键字实现接口类，接口允许多继承。实现类必须实现接口里声明的所有方法，除非是抽象实现类。接口里的方法默认是public abstract；接口中变量默认是public static final。并且不能改为其他修饰符比如private。

接口和抽象类：抽象类中可以有代码块，接口不能有。抽象类中的成员变量和方法可以是其他的修饰符，接口必须是public。类只能继承一个抽象类，可以实现多个接口。
